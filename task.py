"""Вопрос №1"""

def is_even(value):
    return value & 1 == 0

"""Функция is_even использует побитовую операцию, что может быть более эффективным с точки зрения производительности, особенно при работе с большими объемами данных.
Но такой код менее читабельный"""



"""Вопрос №2"""


class FirstWay:
    def __init__(self):
        self._fifo = []

    def get(self):
        try:
            return self._fifo.pop(0)
        except IndexError:
            return None

    def set(self, value):
        self._fifo.append(value)




from collections import deque


class SecondWay:
    def __init__(self):
        self._fifo_que = deque()

    def get(self):
        try:
            return self._fifo_que.popleft()
        except IndexError:
            return None

    def set(self, value):
        self._fifo_que.append(value)


"""Первый класс реализован через список его минус в медленной скорости, так как питон сначала при операции pop смещает каждый элемент влево,
отсюда скорость O(n).

Второй способ реализован через стандартную библиотеку питона deque, которая хранит два связанных списка в одном, что позволят очень быстро
извлекать и добовлять элементы в концы списка, но если попытаться добавить в центр списка значение, это будет значительно дольше.
Скорость данного способа при использовании его как очередь fifo O(1)."""







"""Вопрос №3"""

import random

def sort_mas(mas):
    if len(mas) > 1:
        random_num = mas[
            random.randint(0, len(mas) - 1)]  # Выбираем случаеное значение из списка, с которым потом будем сравнивать
        lower = [el for el in mas if el < random_num]  # Формируем список всех значений, которые меньше чем выбранное
        cur = [el for el in mas if el == random_num]  # Формируем список значений равных выбранному
        high = [el for el in mas if el > random_num]  # Формируем список из значений, которые больше выбранного
        mas = sort_mas(lower) + cur + sort_mas(high)  # рекурсивно вызываем функцию и объеденяем списки
    return mas


'''
Для решения выбранной задачи был выбран алгоритм Хоара, так как он один из самых быстрых. Так как в массиве может быть уже отсортированный список,
поэтому мы берем случайное значение, а не начальный элемент. Это способ использует много памяти, это сделано для увилечения скорости,
но строчки 12-14 можно заменить на сортировку в том же самом массиве, который мы передаём в функцию, это уменьшит расходы памяти
скорость выполнения данного способа сортировки составляет O(N*log2N) 

'''
